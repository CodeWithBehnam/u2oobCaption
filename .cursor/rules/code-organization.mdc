---
alwaysApply: true
description: "Enforce code organization standards: file size limits, modular breakdown, and proper naming"
globs: *.ts,*.js,*.tsx,*.jsx,*.py,*.java,*.cpp,*.c,*.cs,*.php,*.rb,*.go,*.rs,*.swift
---
# Code Organization and File Size Standards

## Primary Rule: File Size Limit (200 Lines Maximum)

**MANDATORY REQUIREMENT**: No code file shall exceed 200 lines of code.

### When to Apply
- All code files in the project (TypeScript, JavaScript, Python, Java, C++, etc.)
- Both new files and existing files being modified
- Core logic files, utility files, and configuration files

### Exceptions
- Generated files (e.g., compiled output, auto-generated code)
- Third-party library files
- Configuration files that are not primarily code (package.json, manifest.json, etc.)
- Test files (though they should also follow modular principles)

## Code Organization Strategy

### For Code Exceeding 200 Lines
If you encounter or need to create code that would exceed 200 lines:

1. **PLAN FIRST**: Break down the functionality into logical components
2. **IDENTIFY SEPARATION POINTS**: Look for natural boundaries in the code
3. **CREATE MULTIPLE FILES**: Split into focused, single-responsibility files
4. **USE PROPER NAMING**: Follow established naming conventions

### File Breakdown Guidelines

#### By Functionality
```
large-file.ts → [
  large-file.core.ts        // Main logic and core functionality
  large-file.utils.ts       // Utility functions and helpers
  large-file.constants.ts   // Constants and configuration
  large-file.types.ts       // Type definitions and interfaces
]
```

#### By Feature Area
```
earthquake-app.ts → [
  earthquake-data.ts        // Data fetching and processing
  earthquake-visualization.ts // Rendering and display logic
  earthquake-controls.ts    // User interaction handling
  earthquake-utils.ts       // Shared utilities
]
```

#### By Layer (Backend)
```
server.ts → [
  server-routes.ts          // API endpoint definitions
  server-middleware.ts      // Request processing logic
  server-config.ts          // Server configuration
  server-utils.ts           // Server utility functions
]
```

## Naming Conventions for Split Files

### Suffix Patterns
- `.core.ts` - Main business logic
- `.utils.ts` - Utility functions and helpers
- `.types.ts` - Type definitions and interfaces
- `.constants.ts` - Constants and configuration
- `.config.ts` - Configuration-specific code
- `.service.ts` - Service layer code
- `.repository.ts` - Data access layer
- `.controller.ts` - Controller/Handler layer
- `.model.ts` - Data models
- `.view.ts` - View/Presentation layer

### Prefix Patterns (When Appropriate)
- `internal-` - Internal implementation details
- `public-` - Public API interfaces
- `private-` - Private utility functions

## Implementation Process

### Step-by-Step Approach
1. **Analyze the large code block** - Identify distinct responsibilities
2. **Create a breakdown plan** - Sketch out the file structure
3. **Extract constants and types** - Move to separate files first
4. **Split utility functions** - Extract reusable helpers
5. **Divide main logic** - Break down core functionality
6. **Update imports** - Fix import/export statements
7. **Test the split** - Ensure functionality remains intact

### Example: Breaking Down a Large Component

**Before**: `earthquake-visualization.ts` (350 lines)
```typescript
// Mixed concerns: data, rendering, interaction, utilities
```

**After**:
- `earthquake-visualization.core.ts` - Main visualization logic (120 lines)
- `earthquake-visualization.utils.ts` - Utility functions (80 lines)
- `earthquake-visualization.types.ts` - Type definitions (45 lines)
- `earthquake-visualization.constants.ts` - Constants and config (35 lines)

## Quality Assurance

### Line Count Verification
- Use IDE extensions or tools to monitor file sizes
- Set up automated checks in CI/CD pipelines
- Regular code reviews should enforce this standard

### Code Review Checklist
- [ ] Does each file have a single, clear responsibility?
- [ ] Are file sizes under 200 lines?
- [ ] Is naming consistent and descriptive?
- [ ] Are imports/exports properly organized?
- [ ] Does the split improve maintainability?

## Benefits of This Approach

1. **Maintainability** - Smaller files are easier to understand and modify
2. **Collaboration** - Multiple developers can work on different files simultaneously
3. **Testing** - Individual components can be tested in isolation
4. **Performance** - IDEs handle smaller files more efficiently
5. **Code Reviews** - Easier to review focused, smaller files

## Migration Strategy for Existing Large Files

When encountering existing files over 200 lines:

1. **Assess the file** - Understand its current structure
2. **Create a migration plan** - Plan the breakdown without breaking functionality
3. **Implement gradually** - Split into smaller files incrementally
4. **Update dependencies** - Fix all references and imports
5. **Test thoroughly** - Ensure no regression in functionality

## Tool Integration

### IDE Configuration
- Configure line count warnings at 150 lines
- Set hard limits at 200 lines
- Enable automatic file splitting suggestions

### Automated Tools
- Pre-commit hooks to check file sizes
- CI/CD pipeline checks for line count limits
- Code analysis tools to suggest file splits

## Enforcement

This rule must be followed for all new code and should be applied when modifying existing code. Code reviews will reject changes that violate the 200-line limit without proper justification and approved breakdown plans.